CLR会为初始化的对象实例在堆中分配一块内存空间，这里面包含类型对象指针、同步块索引和实例字段、基类的实例字段。

## 类型对象指针

类型对象指针就是指向该类的类型对象的一个指针。

所谓类型对象，就是运行时为加载到应用程序中的类型在堆中分配的一块内存区域，该区域中包括的信息有：类型对象指针、同步索引块、静态字段、指向基类的引用字段和方法列表等。每在堆上创建一个对象，CLR都会自动初始化它的类型对象指针，将其指向对象对应的类型对象。

前面说到类型对象内部也存在一个类型对象指针，这个指针指向的是System.Type类型对象，因为所有类型对象都是System.Type类型的实例对象。System.Type的类型对象特殊一些，是指向自身的。

可以用以下方式来获取对象的类型对象引用：
``` C#
var type = new Person().GetType();
```
方法表中保存的是和类型定义的方法一一对应的记录项。

- 当静态方法被调用时，JIT compiler在方法表中找到对应的记录项，将其编译成native code并调用（call）。
- 当非虚实例方法被调用时，JIT compiler首先在方法表中找到对应的记录项（如果没有找到，JIT compiler会一直向上回溯至System.Object），将其编译成native code并调用（callvirt）。
- 当虚实例方法被调用时，JIT compiler根据对象的类型对象指针找到实际的类型对象，并对方法进行JIT编译并调用（callvirt）。

注：通常情况下，IL中的call指令可以调用静态方法、实例方法和虚方法，callvirt可以调用实例方法和虚方法。由callvirt生成的native code会判断发起调用的对象是否为null，性能要差一些。但是在C#中，call用来调用静态方法，callvirt用来调用虚方法和实例方法。

需要注意的是，JIT compiler并不总是将方法编译成native code再调用，以下面的代码举例：

``` C#
Console.WriteLine("Hello world!")
```

当WriteLine方法第一次被调用时，该方法在方法表中对应的记录项指向的是一个"未文档化的函数"（《CLR via C#》中称之为JITCompiler），该函数负责将方法对应的IL编译成native code，并修改方法表记录项的引用，将其指向native code在内存中的地址，最后再执行一次。
当WriteLine方法再次被调用时，该方法在方法表中对应的记录项指向的已经是内存中的native code了，不需要再进行编译。

顺便，由以上的步骤可以知道，JIT compiler编译后的native code是保存在内存中的，程序结束运行后内存被释放，native code也就消失了，这样就可以解释为什么web应用在重启后第一次运行时都会比平时慢一些——除了类型初始化以外，JIT编译也需要耗费一部分时间（其实也可以通过所谓的warmup技术甚至NGen、.Net Native来解决）。


## 同步块索引

而同步块索引，通常情况下用于记录对象在同步块数组中对应的同步块的索引，但不仅限于此。同步块索引格式为32位数字，其中高位的6个数字决定了低位的26个数字代表的意义：

- 线程同步开始后，线程通过检查高位数字来判断有没有其他线程在使用该对象，如果没有，在同步块数组中创建一个同步块，并将同步块索引保存在低位数字中。

  示例代码如下：
  ``` C#
  lock (obj)
  {
      // do something...
  }
  ```
  等价于：
  ``` C#
  try
  {
      Monitor.Enter(obj);
  }
  finaly
  {
      Monitor.Exit(obj);
  }
  ```

  退出线程同步后，修改高位数字将对象标记为未使用状态。

- 调用GetHashCode方法时，低位26个数字用来生成HashCode。需要注意的是，当线程同步进行时，低位数字记录的是同步块索引的值，用于计算HashCode的数字是保存在同步块中的。

- CLR进行垃圾回收时，会修改高位数字，将对象标记为不可回收对象。


## NGen

最后再扯一下前面提到的NGen。

在C#中，编译器将C#代码编译为IL，运行时再由JIT compiler编译为native code。NGen则用于在运行前将IL编译为native code，如此CLR就不需要在运行时调用JIT compiler编译代码了。

此外，经NGen编译后的native code文件可以通过内存映射的方式，同时映射到多个进程地址空间中，避免了每个进程地址空间都单独需要一份代码拷贝。每当CLR加载程序集时，都会检查是否有和程序集对应的native code文件，如果有，就不再对IL进行JIT编译，直接使用编译好的native code。

然而，NGen依然存在一些问题：

- CLR需要访问程序集的元数据用于反射、序列化等功能，所以仍需发布包含IL和元数据的程序集。此外，如果CLR处于某些原因不能使用NGen生成的文件，仍会对IL进行JIT编译，这就要求IL是一直处于可用状态。

- NGen文件加载时将对执行环境（例如Windows版本、CLR版本）进行验证，具体哪些其实我也不懂啦。

- NGen无法像JIT一样对运行环境进行足够多的假设，所以生成的native code运行效果会相对差一些：

  1. 首先，JIT能够根据程序的运行环境来优化生成的代码，举个书中的栗子：

    ``` c#
    if (numbersOfCPUs > 1)
    {
      ...
    }
    ```

    当主机只有一个CPU时，JIT不会为以上代码生成任何native code。

  2. 此外，JIT还可以根据主机的CPU类型生成不同的native code来充分利用CPU的特殊指令集。

###### 参考资料

> http://www.cnblogs.com/jiejie_peng/archive/2011/04/24/2026272.html

> 《CLR via C#》
