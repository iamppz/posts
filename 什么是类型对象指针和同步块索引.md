CLR会为初始化的对象实例在堆中分配一块内存空间，这里面包含类型对象指针、同步块索引和实例字段、基类的实例字段。

# 类型对象指针

类型对象指针就是指向该类的类型对象的一个指针。

所谓类型对象，就是运行时为加载到应用程序中的类型在堆中分配的一块内存区域，该区域中包括的信息有：类型对象指针、同步索引块、静态字段、指向基类的引用字段和方法列表等。每在堆上创建一个对象，CLR都会自动初始化它的类型对象指针，将其指向对象对应的类型对象。

前面说到类型对象内部也存在一个类型对象指针，这个指针指向的是System.Type类型对象，因为所有类型对象都是System.Type类型的实例对象。System.Type的类型对象特殊一些，是指向自身的。

可以用以下方式来获取对象的类型对象引用：
``` C#
var type = new Person().GetType();
```
方法表中保存的是和类型定义的方法一一对应的记录项。

- 当静态方法被调用时，JIT compiler在方法表中找到对应的记录项，将其编译成native code并调用（call）。
- 当非虚实例方法被调用时，JIT compiler首先在方法表中找到对应的记录项（如果没有找到，JIT compiler会一直向上回溯至System.Object），将其编译成native code并调用（callvirt）。
- 当虚实例方法被调用时，JIT compiler根据对象的类型对象指针找到实际的类型对象，并对方法进行JIT编译并调用（callvirt）。

注：通常情况下，IL中的call指令可以调用静态方法、实例方法和虚方法，callvirt可以调用实例方法和虚方法。由callvirt生成的native code会判断发起调用的对象是否为null，性能要差一些。但是在C#中，call用来调用静态方法，callvirt用来调用虚方法和实例方法。

需要注意的是，JIT compiler并不总是将方法编译成native code再调用，以下面的代码举例：

``` C#
Console.WriteLine("Hello world!")
```

当WriteLine方法第一次被调用时，该方法在方法表中对应的记录项指向的是一个"未文档化的函数"（《CLR via C#》中称之为JITCompiler），该函数负责将方法对应的IL编译成native code，并修改方法表记录项的引用，将其指向native code在内存中的地址，最后再执行一次。
当WriteLine方法再次被调用时，该方法在方法表中对应的记录项指向的已经是内存中的native code了，不需要再进行编译。

顺便，由以上的步骤可以知道，JIT compiler编译后的native code是保存在内存中的，程序结束运行后内存被释放，native code也就消失了，这样就可以解释为什么web应用在重启后第一次运行时都会比平时慢一些，除了各种类型初始化以外，JIT编译也需要耗费一部分时间（其实也可以通过所谓的warmup技术甚至Ngen、.Net Native来解决）。


# 同步块索引

而同步块索引，则指向CLR在内存中维持的一个同步块数组中的一个位置。

如果同步块索引为负数，代表没有其他线程使用该对象，在同步块数组中创建一个同步块，并将同步块索引指向该同步块，声明使用该同步块。

如果同步块索引不为负数，则检查指向的同步块是否有其他线程使用，如果没有，声明使用该同步块。

示例代码如下：
``` C#
lock (obj)
{
    // do something...
}
```
等价于：
``` C#
try
{
    Monitor.Enter(obj);
}
finaly
{
    Monitor.Exit(obj);
}
```

###### 参考资料

> http://www.cnblogs.com/jiejie_peng/archive/2011/04/24/2026272.html
